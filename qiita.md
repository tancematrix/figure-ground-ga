先日バズった岐阜新聞の広告「離れていても、心はひとつ」をご存知でしょうか。([yahoo! newsなどで紹介されています](https://news.yahoo.co.jp/articles/6a90515f951be8184e68b49677356d954548e60c))

一見すると黒地に白い水玉模様なのですが、離れて（あるいはメガネを外して）見ると白地に書かれた黒い文字が浮かび上がってきます。

同じように「黒い背景に」「白い円を配置し」「結果として黒い字が読める」画像を自動で生成できたら面白いなと思ってやってみました。

# 結論から
遺伝的アルゴリズムを使うとできた。
実装は[github](https://github.com/tancematrix/figure-ground-ga)
左が目標画像で右が生成画像です。（まだできていないのではれない）

# 本記事の内容

- どうやったら「離れたら読める画像」の生成ができるか、遺伝的アルゴリズムを採用するに至るまでの思考の経緯
- 遺伝的アルゴリズム実装例略解


# どうやったら「離れたら読める画像」の生成ができるか?

## 準備: プログラムの流れ
まず、プログラムの概要としては次のようなものを想定しました。

1. 目標画像と、目標画像と同じサイズの真っ黒の画像を用意する。
2. パラメータとして、[円の位置(xy座標), 円の半径] を円の数だけ保持する。（ランダムに初期化する） 
3. パラメータを元に、真っ黒の画像に白い円を描画する(生成画像)。
4. 生成画像の「離れると読める」度の評価値を計算する。
5. 評価値を最適化するようなパラメータを求める。

1,2,3は問題なさそうです。ちなみに3については、各円の座標・半径に対して内部が0, 外部が1であるようなmaskを生成し, 全ての円に関して積を取ることで実現しています。以下のような感じです。（都合上、白地に黒い円を描く感じになっています。最後に色を反転させています）

```python
def circle_mask(shape, cx, cy, r):
    x, y = np.ogrid[:shape[0], :shape[1]]
    r2 = (x-cx)*(x-cx) + (y-cy)*(y-cy)
    mask = r2 > r ** 2
    return mask

def encode(shape, params):
    # paramsは[x座標, y座標, 半径] * 円の数 であるnumpy 2d-array, shapeは生成画像のサイズ
    _circle_mask = lambda cx, cy, r: circle_mask(shape, cx, cy, r) # 部分適用的な
    mask = np.multiply.reduce(np.apply_along_axis(_circle_mask, 1, params))
    return np.ones(shape) * mask
```
問題は4と5です。以下で詳細に触れます。

## なぜあの広告は「離れると読める」 のか?
基本的にはあの広告は有名な錯視「ルビンの壺」と同じ原理です。人は白と黒（白と黒でなくてもいいですが）からなる画像を見ると、どちらかを「図」（意味的なまとまり）どちらかを「地」（背景） と認識します。
![image.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/460873/94bd805b-5de5-f07d-f26f-7454f1b44608.png)

「図」と「地」というのはゲシュタルト心理学([wikipedia](https://ja.wikipedia.org/wiki/%E3%82%B2%E3%82%B7%E3%83%A5%E3%82%BF%E3%83%AB%E3%83%88%E5%BF%83%E7%90%86%E5%AD%A6#%E3%83%97%E3%83%AC%E3%82%B0%E3%83%8A%E3%83%B3%E3%83%84%E3%81%AE%E6%B3%95%E5%89%87))における用語で、デザイン分野なんかでは馴染みのある言葉のようです。
問題の広告においては、近くで見ると円が「図」になり、離れて見ると文字が「図」になります。
これは、人間が「まとまりがある方」を「図」として認識する、という法則（プレグナンツの法則）によります。近くでみたとき、円(白)は円というまとまりで認識できる一方で文字(黒)はガタガタしていて、まとまりがありません。

しかし、離れてみると画像はぼやけて解像度が下がります。ぼやけることによって、文字(黒)のガタガタは平滑化され、気にならなくなります。こうなると、文字を「まとまり」として認識するため、文字が見えるという仕組みです。

なお、目のいい人なら「ちょっと離れたくらいではぼやけて見えてなんかいないぞ」と感じるかもしれません。
人間の目においてパシッとピントを合わせられるのはごく狭い範囲なのですが、視野の中心のピントが合っていたら全体として「ぼやけていない」ように見えます。でも、実際のところ視野の中心以外はぼやけています。今読んでいるこの文も、今まさに読んでいる数文字以外はぼやけています。試してみてください。

## 「離れたら読める」 はどう表現できるか
人間の目（というかレンズ一般）の「ぼけ」はガウシアンフィルタの畳み込みで表現できます。そこで、目標画像と生成画像にフィルタをかけた後の両者の距離が十分に小さければ「離れたら読める」 画像であると言えると考えました。つまり、以下のような手順になります。

1. 目標画像・生成画像にガウシアンフィルタをかけ、ダウンサンプリングする[^1]。
2. ダウンサンプル後の2つの画像のL2ノルムを距離=評価値とする。

[^1]: 畳み込みは線形操作なので、畳み込みの差=差の畳み込みです。実際のコードでは畳み込みの処理回数を減らすために、差を取ってからたたみ込んでいます。
ガウシアンフィルタはscipyに`scipy.ndimage.gaussian_filter()`が備わっていたので利用しました。画像の距離がL2ノルムというのは乱暴かもしれませんが、簡単のために採用しました。
mnistなどで事前学習したCNNによる特徴量のcos距離...とかにするとさらに本格的だとは思います。
![image.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/460873/fcdabc2a-619e-1f04-a834-555b11854b95.png)


具体的には評価関数は概ね次のように実装しました。

```python
    def evaluate(target_image, generated_image):
        ds_rate = min(target_image) // 20 # 画像の短辺が20pixになるようなダウンサンプルレート
        down_sampled_generated = scipy.ndimage.gaussian_filter(generated_image, sigma=ds_rate)[::ds_rate, ::ds_rate]
        down_sampled_target = scipy.ndimage.gaussian_filter(target_image, sigma=ds_rate)[::ds_rate, ::ds_rate]
        return np.linalg.norm(down_sampled_morph - down_sampled_target)
```

## パラメータをどうやって最適化するか
はじめに考えたのは、最適化問題として解くことです。しかし、パラメータ->評価値の関数をちゃんと定義して適切に解くほどの数学力は僕にはありませんでした...

次に目をつけたのは「図形詰め込みアルゴリズム([参考pdf](http://www.orsj.or.jp/archive2/or63-12/or63_12_762.pdf))」という最適化アルゴリズムです。与えられた空間内に与えられた図形をできるだけみっちり詰め込むというタスクで、これに落とし込むことができれば解けそうだと考えました。
一方でこのアルゴリズムは詰め込む図形同士が「接している」ということを重要な手がかりとして使っているのですが、今回配置したい円は離れていてもよく、重なっていても構いません。
その道の専門家なら難なく条件を変化させて解いてしまうのかもしれませんが、僕にはこれも難しそうだったので諦めました。

最後に、遺伝的アルゴリズムを考えました。円の配置とサイズを遺伝情報として持っておいて、その評価値さえ得られればいい[^2]ので、これならできそうに思えました。遺伝的アルゴリズムには以前から興味を持っていましたが実装したことはなかったので、0から実装してみることにしました。

Pythonで0からクラス設計を行ったのも初めてなので、ご指導ご鞭撻のほどよろしくお願いいたします。

# 遺伝的アルゴリズムの実装
##遺伝的アルゴリズム略解 
遺伝的アルゴリズムについては[このスライド](https://www.slideshare.net/kzokm/genetic-algorithm-41617242)が非常にわかりやすいです。
ここでは必要最低限の解説をします。（間違いの指摘をお願いいたします）

まず、遺伝的アルゴリズムには以下の構成要素があります。

- 獲得したいパラメータを格納する**ゲノム**
- ゲノムをもつ**個体**
- 個体の集合である**世代**

これらに対して以下の操作を行います。

1. 得体パラメータをゲノムとしてエンコードし、個体に割り当てる。
1. 一定数の個体の集合を現世代とする。
1. 現世代の各個体の評価値を計算する。
1. 世代内の2個体をある確率で選び、**交差**を行う。<br>
     交差: 2個体の持つゲノムの一部を入れ替えることによって新たに2つのゲノム(=子孫)を生成する
1. 交差によって生成した子孫にある確率で**突然変異**を起こす。<br>
     突然変異: ゲノムの一部に変化を加える。
1. 子孫と現世代の中から、次世代に残すゲノムを**選択**する。
1. 現世代を次世代で置換して(**世代交代**)以上の操作を繰り返す。

交差の親個体の選び方や選択の仕方は色々あって、それらの確率を評価値に依存させることでより良いゲノムを残していきます。今回、採用した戦略は以下の通りです。

- エンコーディング: 実数値エンコーディング
    - ゲノムは1d-arrayとして表現するのが普通なのかもしれませんが、今回は[[円のx座標, 円のy座標, 円の半径] * 円の数]という実数値2d-arrayをゲノムとしました。
- 評価値: 前述
- 交差方法: 二点交差
- 突然変異: 置換（ランダムに選ばれた遺伝子を、一様乱数によって書き換える）のみ
- 世代交代: 世代間最小ギャップモデル(後述)

## 世代間最小ギャップモデル

今回実装したのは「世代間最小ギャップモデル」というモデルです。次の手順で世代交代を行います。

1. ある世代からランダムに2個体を選んで交差し、子個体2体を得る（合計4個体）
1. 合計4個体のうち、最も評価値の良い1個体を生存個体_1として選ぶ。
1. 残った3個体のうちから、ルーレット選択によって確率的に1個体を選び、生存個体_2とする。
1. 2体の生存個体によって親個体を置換したもの（ただし、親自身も生存個体となりうる）をを次世代とする。

すなわち、一回の世代交代で入れ替わる個体は最大2個体です。親個体の選択がランダムである（評価値によらない） ため、世代内の多様性の維持に優れており、計算コストも低く抑えられます。
## Class構成
詳細は[github](https://github.com/tancematrix/figure-ground-ga)にあります。
以下の4つのクラスによってプログラムを構成しました。Phenotypeクラスにゲノムを渡すと形質が発現する、という設計にするとかっこいいなと思って作ったのですが、あまり使い勝手のいい出来にはなりませんでした...。

main関数はシンプルに書けて、以下のような感じです。ただし`target`は目標画像(ndarray)です。

```python
g = Generation(generation_size=GENERATION_SIZE, genom_length=circle_num, genom_limits=[height, width, min(height, width) // 2], pm=0.05)
for i in range(ITER_NUM):
    g.evaluate(255-target)
    min_score, max_score, ave_score = g.summary()
    if mi < THRESHOLD:
        print("score achieved, break..")
        break
    g.mgg_change(255-target)
```


- Genom(genom_length:int, genom_limits:array-like)
    - [円のx座標, 円のy座標, 円の半径] * genom_length に相当するゲノム(2d-array)を格納することを主な目的としたクラス。

- Phenotype(g:Genom, shape:array-like)
    - genomの発現を管理するクラス。コンストラクタはGenomと生成画像のshapeを引数にとる。genom内の円の位置・サイズ情報を元に、画像にエンコードする。
    - `evaluate(target)`メソッドによってgenomの評価値を返す。targetはtarget文字画像。

- Family(g1:Genom, g2:Genom)
    - 交差を司るクラス。コンストラクタは親となる2個体の`Genom`を引数にとる。
    - `mgg_change(target, pm)`メソッドによって世代間最小ギャップモデルに基づく世代交代における生存個体（2個体）を返す。

- Generation(args)
    - genomの集合である世代を管理するクラス。コンストラクタに世代サイズや突然変異確率などの設定を渡す。
    - `mgg_change(target)`メソッドで世代間最小ギャップモデルに基づく世代交代を行う。
        - 基本的にこのメソッドを繰り返すことで遺伝的アルゴリズムが実行される。

[^2]: 不正確な言い方ですが。
